<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/JuliaNotes/libs/highlight/github.min.css"> <link rel=stylesheet  href="/JuliaNotes/css/franklin.css"> <link rel=stylesheet  href="/JuliaNotes/css/pure.css"> <link rel=stylesheet  href="/JuliaNotes/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/JuliaNotes/assets/favicon.png"> <title>Issues and Tricks</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/JuliaNotes/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu1/" class=pure-menu-link >Questions</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu2/" class=pure-menu-link >Types</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu3/" class=pure-menu-link >Meta</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu4/" class=pure-menu-link >Parallel</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu5/" class=pure-menu-link >Interoperability</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu6/" class=pure-menu-link >Issues and Tricks</a> </ul> </div> </div> <div id=main > <div class=header > <h1>Issues and Tricks</h1> <h2>Notes taken during the learning process</h2> </div> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#type_stability">Type Stability</a><li><a href="#avoid_memory_allocation">Avoid Memory Allocation</a><ol><li><a href="#using_array_views_to_avoid_memory_allocation">Using array views to avoid memory allocation</a><li><a href="#static_arrays">Static arrays</a></ol><li><a href="#benchmarking_tools">Benchmarking tools</a><li><a href="#common_misunderstandings">Common Misunderstandings</a><li><a href="#issues">Issues</a></ol></div> <h1 id=issues_and_tricks ><a href="#issues_and_tricks">Issues and Tricks</a></h1> <p>Here is a nice <a href="https://www.juliabloggers.com/7-julia-gotchas-and-how-to-handle-them/">blog: 7 Julia Gotcha</a> for some basic and easily ignored tips.</p> <ul> <li><p>The dot operator <code>.</code> stands in the heart of array operations. As the language evolves after Julia 1.0, there are more restrictions on the usage of dots. <code>.</code> in Julia is just a shorthand for the <code>broadcast</code> function. Consider the following example:</p> </ul> <pre><code class="julia-repl hljs">exp.(sin.(cos.(log.(1:100))))</code></pre>
<p>The preceding code is fused into an operation similar to the following:</p>
<pre><code class="julia-repl hljs">broadcast(v -&gt; exp(sin(cos(log(v)))), 1:100)</code></pre>
<p>The consequence is that there is only one allocation of memory to produce the final result of the operation. In standard scripting languages, each step of the computation would typically use up new memory. This is both computationally inefficient and memory expensive. Such seemingly minor details make Julia shine in numerical computing applications.</p>
<p>I am so used to the MATLAB style of vectorization, so I usually write the code like</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > lat.f[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>,:] = (w[<span class=hljs-number >1</span>]+w[<span class=hljs-number >3</span>])*T[<span class=hljs-number >1</span>] .- lat.f[<span class=hljs-number >3</span>,<span class=hljs-number >1</span>,:]</span></code></pre>
<p>Actually in MATLAB you don&#39;t even need the dot operation for plus and minus. However, in Julia any fusion operation requires the explicit dot operation, even the equal sign&#33; So the above example may not be optimal as you would expect: it is a copy instead of in-place operation&#33;</p>
<p>The correct one should be:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > lat.f[<span class=hljs-number >1</span>,<span class=hljs-number >1</span>,:] .= (w[<span class=hljs-number >1</span>]+w[<span class=hljs-number >3</span>])*T[<span class=hljs-number >1</span>] .- lat.f[<span class=hljs-number >3</span>,<span class=hljs-number >1</span>,:]</span></code></pre>
<p>See an elegant and detailed <a href="https://julialang.org/blog/2017/01/moredots">description to the dot operations</a> by Steven Johnson, a professor at MIT.</p>
<ul>
<li><p>By default, a plot will not show up automatically inside a function. It is only displayed when it&#39;s returned. Otherwise, you can use, e.g., <code>display&#40;plot&#40;f, -3, 3&#41;&#41;</code> to show the plot.</p>

</ul>
<ul>
<li><p>The differential equation solver packages are extremely powerful. Read existing availability before you jump into writing your own version&#33;</p>

</ul>
<ul>
<li><p>If the string also includes quotes, we can escape these by prefixing them with a backslash:</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;Beta is Latin for \&quot;still doesn&#x27;t work\&quot;.&quot;</span></span></code></pre>
<p>However, escaping can get messy, so there&#39;s a much better way of dealing with this –- by using triple quotes &quot;&quot;&quot;...&quot;&quot;&quot;.</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;&quot;&quot;Beta is Latin for &quot;still doesn&#x27;t work&quot;.&quot;&quot;&quot;</span></span></code></pre>
<p>Within triple quotes, it is no longer necessary to escape the single quotes. However, make sure that the single quotes and the triple quotes are separated –- or else the compiler will get confused:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;&quot;&quot;Beta is Latin for &quot;still doesn&#x27;t work&quot;&quot;&quot;</span><span class=hljs-string >&quot; 
</span></span>
syntax: cannot juxtapose string literal</code></pre>
<p>The triple quotes come with some extra special power when used with multiline text. First, if the opening &quot;&quot;&quot; is followed by a newline, this newline is stripped from the string. Also, whitespace is preserved but the string is dedented to the level of the least-indented line:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;&quot;&quot; 
</span></span>
                  Hello 
           Look 
    Here&quot;&quot;&quot;

<span class=hljs-meta >julia&gt;</span><span class=julia ><span class=hljs-string > print(ans) 
</span></span>
Hello 
Look 
Here</code></pre>
<p>The previous snippet illustrates how the first line is stripped and the whitespace is preserved—but the indentation starts with the least indented line &#40;the space in front of &#39;Here&#39; was removed&#41;.</p>
<ul>
<li><p>Concatanating strings</p>

</ul>
<p>Strings can be concatenated with an asterisk operator <code>*</code>, but this ONLY works for strings. To deal with other types, use string function:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > string(greeting, <span class=hljs-string >&quot;, &quot;</span>, username)
</span>
&quot;Good morning, 9543794&quot;
<span class=hljs-meta >julia&gt;</span><span class=julia > string(<span class=hljs-number >2</span>, <span class=hljs-string >&quot; and &quot;</span>, <span class=hljs-number >3</span>) 
</span>
&quot;2 and 3&quot;</code></pre>
<p>There is also a <code>String</code> method &#40;with capital S&#41;. Remember that in Julia names are case-sensitive, so string and String are two different things. For most purposes we&#39;ll need the <code>lowercase</code> function.</p>
<ul>
<li><p>Interpolating strings</p>

</ul>
<p>When creating longer, more complex strings, concatenation can be noisy and error-prone. For such cases, we&#39;re better off using the <code>&#36;</code> symbol to perform variable interpolation into strings:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > username = <span class=hljs-string >&quot;Adrian&quot;</span> 
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > greeting = <span class=hljs-string >&quot;Good morning&quot;</span> 
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;<span class=hljs-variable >$greeting</span>, <span class=hljs-variable >$username</span>&quot;</span> 
</span>
&quot;Good morning, Adrian&quot;</code></pre>
<p>More complex expressions can be interpolated by wrapping them into <code>&#36;&#40;...&#41;</code>:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;<span class=hljs-subst >$(uppercase(greeting)</span>), <span class=hljs-subst >$(reverse(username)</span>)&quot;</span> 
</span>
&quot;GOOD MORNING, nairdA&quot;</code></pre>
<p>Just like the string function, interpolation takes care of converting the values to strings:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-string >&quot;The sum of 1 and 2 is <span class=hljs-subst >$(<span class=hljs-number >1</span> + <span class=hljs-number >2</span>)</span>&quot;</span> 
</span>
&quot;The sum of 1 and 2 is 3&quot;</code></pre>
<ul>
<li><p><code>varinfo&#40;&#41;</code> is approximately equal to <code>whos</code> in MATLAB. SOME IDEs now have support for showing the variables in the current scope, which is extremely helpful.</p>

</ul>
<ul>
<li><p>Julia has alias. For instance, the <code>Int</code> type will reflect that, as it&#39;s just an alias to either <code>Int32</code> or <code>Int64</code>:</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@show</span> <span class=hljs-built_in >Int</span> 
</span>
Int = Int64</code></pre>
<ul>
<li><p><code>@which</code> can be used to show which method is actually being called with Julia&#39;s multi-dispatch system.</p>

</ul>
<ul>
<li><p>To find out what methods are defined for a function, use <code>methods&#40;&#41;</code>:</p>

</ul>
<ul>
<li><p>An easy way to load CSV/TSV file into Julia is by using the <code>readdlm</code> function, which is available in the <code>DelimitedFiles</code> module. If you use <code>skipstart</code> only, then an array is returned; if instead you use <code>header&#61;true</code>, this would change the return type of the function invocation to a tuple of <code>&#40;data_cells, header_cells&#41;</code>. This is an old module, with fast but limited functionality support. For more advanced reading, you can use <a href="https://github.com/JuliaData/CSV.jl">CSV.jl</a> package. This will return a <code>DataFrame</code> object instead of array.</p>

</ul>
<ul>
<li><p>We can check if a value is missing by using the <code>ismissing</code> function.</p>

</ul>
<ul>
<li><p>Unfortunately, transposing doesn&#39;t work smoothly for all kinds of matrices in Julia 1.1 yet, and the recommended way is to do this via <code>permutedims</code> &#40;especially for a mixture of types&#41;.</p>

</ul>
<ul>
<li><p>If the REPL output is too wide, it will omit some of the <code>DataFrame</code> columns. To get Julia to display all the columns, you can use the <code>showall</code> function.</p>

</ul>
<ul>
<li><p>In some parts of the code, you can avoid temporary memory allocation by <code>@view</code>. For example, if we want to pick a submatrix from A, we can do</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > block = A[i-<span class=hljs-number >1</span>:i+<span class=hljs-number >1</span>,j-<span class=hljs-number >1</span>:j+<span class=hljs-number >1</span>] <span class=hljs-comment ># allocate temporary var</span>
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > block = <span class=hljs-meta >@view</span> A[i-<span class=hljs-number >1</span>:i+<span class=hljs-number >1</span>,j-<span class=hljs-number >1</span>:j+<span class=hljs-number >1</span>] <span class=hljs-comment ># no allocation</span></span></code></pre>
<ul>
<li><p>The macro <code>@code_native</code> shows the assembly code.</p>

</ul>
<ul>
<li><p>Do-Block: the <code>do x</code> syntax creates an anonymous function with argument <code>x</code> and passes it as the first argument to the preceding function. The implementation of do-block syntax is mind-refreshing and elegant.</p>

</ul>
<ul>
<li><p><code>rand</code> and <code>rand&#33;</code> has the ability to pick a random value from a given data. The latter one with exclamation mark can fill random value into a given data array.</p>

</ul>
<ul>
<li><p>Julia uses <code>im</code> for indicating imaginary numbers.</p>

</ul>
<ul>
<li><p>The equivalent of <code>linspace</code> in Julia is <code>range&#40;a, stop &#61; b, length &#61; c&#41; |&gt; collect</code>.</p>

</ul>
<ul>
<li><p>Adding <code>;</code> in square bracket can change the return type to an array as you would expect. For example,</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > x = [<span class=hljs-number >1</span>:<span class=hljs-number >10</span>]
</span>
1-element Array{UnitRange{Int64},1}:
 1:10
<span class=hljs-meta >julia&gt;</span><span class=julia > x = [<span class=hljs-number >1</span>:<span class=hljs-number >10</span>;]
</span>
10-element Array{Int64,1}:</code></pre>
<ul>
<li><p><code>&#36;</code> can be used to protect the functions that we do not want to broadcast, when used together with <code>@</code>.</p>

</ul>
<ul>
<li><p>Often, especially in performance-critical code, we want to squeeze the maximum speed out of Julia. If you are working with arrays, the <code>@inbounds</code> macro can be used to significantly reduce access time to the elements. The drawback is that you have to be sure that you are not trying to access an out-of-bounds location. The index boundary check can be turned off also by adding the <code>--check-bounds&#61;no</code> flag to Julia.</p>

</ul>
<p>If you are developing a function in which you want to allow its user to disable bounds checking, you can use the <code>@boundscheck</code> macro. Here is an example function definition from <code>base/bitarray.jl</code>:</p>
<pre><code class="julia-repl hljs">@inline function getindex(B::BitArray, i::Int)
    @boundscheck checkbounds(B, i)
    unsafe_bitgetindex(B.chunks, i)
end</code></pre>
<p>This annotation will only have an effect if the function, <code>getindex</code> in this case, is inlined into a caller. Therefore, the <code>@inline</code> macro is used at the beginning of its definition.</p>
<ul>
<li><p>A symbol is used to represent a variable in metaprogramming. Once you have symbols as a data type, of course, it becomes tempting to use them for other things, like as hash keys. But that&#39;s an incidental, opportunistic usage of a data type that has another primary purpose. Potentially using symbols over strings can speed up your Dict operations&#33;</p>

</ul>
<ul>
<li><p>There are some general rules in the <a href="https://github.com/JuliaPlots/Plots.jl">Plot.jl</a> package that are useful to remember. For any matrix input, each column represents a data series and each row represents a data point. No matter it is x, y, labels, etc..</p>

</ul>
<ul>
<li><p>There is a macro called <code>@debug</code>, which only evaluates the statements after when debug logging is enabled. The level of logging can be selected by an environment variable <code>JULIA_DEBUG</code>.</p>

</ul>
<ul>
<li><p>Take advantage of one-line functions for your work. For example, to search for all the files with keywords in the directory, you can do</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > searchdir(path,key) = filter(x-&gt;occursin(key,x), readdir(path))</span></code></pre>
<ul>
<li><p>In some cases, <code>ifelse</code> can improve performance from <code>?</code> due to the avoid of branches.</p>

</ul>
<ul>
<li><p>There is a pipeline operator in Julia, similar to Bash:</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > trunc(-<span class=hljs-number >1.5</span>) |&gt; typeof</span></code></pre>
<p>In this way, we can change some operations into a more readable form.</p>
<ul>
<li><p>If you really care about performance, try the <code>@fastmath</code> macro.</p>

</ul>
<ul>
<li><p>For the common loops, using <code>for i in 1:length&#40;A&#41;</code> is fine and equivalent to <code>for i in eachindex&#40;A&#41;</code>. However, if A is an <code>abstractArray</code> that may be a <code>subArray</code> &#40;view of array&#41; that includes some non-continuous indexing, using <code>eachindex</code> is better.</p>

</ul>
<ul>
<li><p>MATLAB <code>squeeze</code> is equivalent to <code>dropdims</code> in Julia.</p>

</ul>
<ul>
<li><p>Julia has macros defined in package like Cascadia and <a href="https://github.com/stevengj/LaTeXStrings.jl">LaTeXStrings</a>:</p>

</ul>
<pre><code class="julia-repl hljs">using Cascadia
sm = sel&#x27;&#x27;#content.mw-body&#x27;&#x27;
L&#x27;&#x27;\alpha&#x27;&#x27;</code></pre>
<ul>
<li><p>I once had a task of finding all the missing numbers in a sequence 0:2000. There are many ideas, but in Julia the simplest one is using Set, combining with the <code>setdiff</code> function.</p>

</ul>
<ul>
<li><p>Since 2018, <code>Statistics</code> package is moved out of <code>stdlib</code> into <code>StatsBase</code> package, but it still maintains the acronym.</p>

</ul>
<ul>
<li><p>The <code>using</code> statement is not allowed inside functions. If you really want to do it, add a <code>@eval</code> in the front of <code>using</code>.</p>

</ul>
<h2 id=type_stability ><a href="#type_stability">Type Stability</a></h2>
<p>If there is one thing that has a direct and massive impact on the performance of Julia code, it&#39;s the type system. And the most important thing about it is to write code that is <strong>type-stable</strong>. Type stability means that the type of a variable &#40;including the return value of a function&#41; must not vary with time or under different inputs. Understanding how to leverage type stability is key to writing fast software. Now that we know how to measure our code&#39;s execution time, we can see the effect of type instability with a few examples.</p>
<p>Let&#39;s take this innocent-looking function, for example:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >function</span> f1() 
</span>
           x = 0 
 
           for i in 1:10 
               x += sin(i) 
           end 
            
           x 
       end 
f1 (generic function with 1 method)</code></pre>
<p>There&#39;s nothing fancy about it. We have a variable, <code>x</code>, which is initialized to 0 –- and then a loop from 1 to 10, where we add the <code>sin</code> of a number to <code>x</code>. And then we return <code>x</code>. Nothing to see, right? Well, actually, quite the contrary –- a few bad things, performance-wise, are happening here. And they all have to do with type instability.</p>
<p>Julia provides a great tool for inspecting and diagnosing code for type-related issues –- the <code>@code_warntype</code> macro. Here&#39;s what we get when we use it with our <code>f1</code> function:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@code_warntype</span> f1()</span></code></pre>
<p>Check for the output, especially the color coding parts. As you might expect, green is good and red is bad. The problems are with <code>Body::Union&#123;Float64, Int64&#125;</code> on the first line, <code>&#40;#4 &#61;&gt; 0, #14 &#61;&gt; &#37;29&#41;::Union&#123;Float64, Int64&#125;</code> on line 12, and <code>&#40;#13 &#61;&gt; &#37;29, \#4 &#61;&gt; 0&#41;::Union&#123;Float64, Int64&#125;</code> on the penultimate line.</p>
<p>On the first line, the <code>Body::Union&#123;Float64, Int64&#125;</code>, as well as on the penultimate line, <code>::Union&#123;Float64, Int64&#125;</code>, tell us the same thing –- the function returns a <code>Union&#123;Float64, Int64&#125;</code>, meaning that the function can return either a Float or an Integer. This is textbook type instability and bad news for performance. Next, on line 12, something has a type of <code>Union&#123;Float64, Int64&#125;</code> and this value is then returned as the result of the function. In case you&#39;re wondering, that something is <code>x</code>.</p>
<p>The problem is that we unsuspectingly initialized <code>x</code> to 0, an Integer. However, the <code>sin</code> function will return a Float. Adding a Float to an Integer will result in a Float, causing the type of <code>x</code> to change accordingly. Thus, <code>x</code> has two types during the execution of the function, and since we return <code>x</code>, our function is also type-unstable.</p>
<p>Granted, understanding the output of <code>@code_warntype</code> is not easy, although it does get easier with time. However, we can make our job easier by using the super-useful <a href="https://github.com/JunoLab/Traceur.jl">Traceur.jl</a> package. It provides a <code>@trace</code> macro, which generates human-friendly information. Let&#39;s add it and try it out; you&#39;ll appreciate it:</p>
<pre><code class="julia-repl hljs"><span class=hljs-metap>(IssueReporter) pkg&gt;</span> add Traceur 
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >using</span> Traceur 
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@trace</span> f1() 
</span>
┌ Warning: x is assigned as Int64 
└ @ REPL[94]:2 
┌ Warning: x is assigned as Float64 
└ @ REPL[94]:4 
┌ Warning: f1 returns Union{Float64, Int64} 
└ @ REPL[94]:2 
1.4111883712180104</code></pre>
<p>How cool is that? Crystal clear&#33; </p>
<p>With this feedback in mind, we can refactor our code into a new <code>f2</code> function:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >function</span> f2() 
</span>
           x = 0.0 
 
           for i in 1:10 
                  x += sin(i) 
           end 
 
           x 
       end 
f2 (generic function with 1 method) 
 
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@trace</span> f2() 
</span>
1.4111883712180104</code></pre>
<p>Awesome, nothing to report&#33; No news is good news&#33;</p>
<p>Now, we can benchmark <code>f1</code> and <code>f2</code> to see the result of our refactoring:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> f1() 
</span>
  129.413 ns (0 allocations: 0 bytes) 
1.4111883712180104 
 
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> f2() 
</span>
  79.241 ns (0 allocations: 0 bytes) 
1.4111883712180104</code></pre>
<h2 id=avoid_memory_allocation ><a href="#avoid_memory_allocation">Avoid Memory Allocation</a></h2>
<h3 id=using_array_views_to_avoid_memory_allocation ><a href="#using_array_views_to_avoid_memory_allocation">Using array views to avoid memory allocation</a></h3>
<h3 id=static_arrays ><a href="#static_arrays">Static arrays</a></h3>
<p>In the current implementation, working with large <code>StaticArrays</code> puts a lot of stress on the compiler, and becomes slower than <code>Base.Array</code> as the size increases. A very rough rule of thumb is that you should consider using a normal Array for arrays larger than 100 elements. </p>
<h2 id=benchmarking_tools ><a href="#benchmarking_tools">Benchmarking tools</a></h2>
<p>Given its focus on performance, it should come as no surprise that both core Julia and the ecosystem provide a variety of tools for inspecting our code, looking for bottlenecks and measuring runtime and memory usage. One of the simplest is the <code>@time</code> macro. It takes an expression and then prints its execution time, number of allocations, and the total number of bytes the execution caused to be allocated, before returning the result of the expression. For example, note the following:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@time</span> [x <span class=hljs-keyword >for</span> x <span class=hljs-keyword >in</span> <span class=hljs-number >1</span>:<span class=hljs-number >1_000_000</span>]; 
</span>
  0.031727 seconds (55.85 k allocations: 10.387 MiB)</code></pre>
<p>Generating an array of one million integers by iterating from one to one million takes 0.03 seconds. Not bad, but what if I told you that we can do better –- much better? We just committed one of the cardinal sins of Julia—code should not be run &#40;nor benchmarked&#41; in the global scope. So, rule one –- always wrap your code into functions.</p>
<p>The previous snippet can easily be refactored as follows:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >function</span> onetomil()  
</span>
            [x for x in 1:1_000_000]
       end 
onetomil (generic function with 1 method)</code></pre>
<p>Now, the benchmark is as follows:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@time</span> onetomil();
</span>
  0.027002 seconds (65.04 k allocations: 10.914 MiB)</code></pre>
<p>All right, that&#39;s clearly faster –- but not much faster. However, what if we run the benchmark one more time?</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@time</span> onetomil();
</span>
  0.002413 seconds (6 allocations: 7.630 MiB)</code></pre>
<p>Wow, that&#39;s an order of magnitude faster&#33; So, what gives?</p>
<p>Julia uses a just-in-time &#40;JIT&#41; compiler; that is, a function is compiled in real time when it is invoked for the first time. So, our initial benchmark also included the compilation time. This brings us to the second rule –- don&#39;t benchmark the first run.</p>
<p>The best way to accurately measure the performance of a piece of code, thus, would be to execute it multiple times and then compute the mean. There is a great tool, specially designed for this use case, called <code>BenchmarkTools</code>. Let&#39;s add it and give it a try:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >using</span> BenchmarkTools 
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@benchmark</span> onetomil() 
</span>
BenchmarkTools.Trial: 
  memory estimate:  7.63 MiB 
  allocs estimate:  2 
  -------------- 
  minimum time:     1.373 ms (0.00% GC) 
  median time:      1.972 ms (0.00% GC) 
  mean time:        2.788 ms (34.06% GC) 
  maximum time:     55.129 ms (96.23% GC) 
  -------------- 
  samples:          1788 
  evals/sample:     1</code></pre>
<p>We can also use the more compact <code>@btime</code> macro, which has an output similar to <code>@time</code>, but executes an equally comprehensive benchmark:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-meta >@btime</span> onetomil(); 
</span>
  1.363 ms (2 allocations: 7.63 MiB</code></pre>
<p><a href="https://github.com/JuliaCI/BenchmarkTools.jl/blob/master/doc/manual.md">BenchmarkTools</a> exposes a very rich API and it&#39;s worth getting to know it well.</p>
<p>For packages, there is a helper library <a href="https://github.com/JuliaCI/PkgBenchmark.jl">PkgBenchmark</a> which let you define a suite of tests for benchmark. However, this timing really depends not only on the code itself, but also the testing environment, machine and setup.</p>
<p>One more thing to keep in mind here: timing by itself is very tricky. If doing inappropriately, you may only end up in timing the part you don&#39;t want &#40;e.g. garbbage collection&#41;. Check the advices by experts&#33;</p>
<h2 id=common_misunderstandings ><a href="#common_misunderstandings">Common Misunderstandings</a></h2>
<p>Now you may have the impression that writing Julia code is like writing a static-typed language: the performance is gained by specifying every single argument of the functions. This is not true&#33; Type assertions in function arguments are mainly used to control multiple dispatch, which has nothing to do with performance. To get performance in Julia the important hint is not annotating with types, but achieving type stability. This simply means that upon executing a piece of code, the variable types don&#39;t change.</p>
<p>There is an excellent explanation to this on StackOverFlow.</p>
<h2 id=issues ><a href="#issues">Issues</a></h2>
<ul>
<li><p>Differences between assignment, copy and deepcopy for mutable and immutable objects.</p>

</ul>
<pre><code class="julia hljs">a = ones(<span class=hljs-number >3</span>)
b = a
b[<span class=hljs-number >1</span>] = <span class=hljs-number >2.0</span></code></pre>
<p>then <code>a</code> will also change. However, if you assign <code>b</code> to another type</p>
<pre><code class="julia hljs">a = ones(<span class=hljs-number >3</span>)
b = a
b = <span class=hljs-number >2</span></code></pre>
<p>then <code>a</code> will not change.</p>
<p>One common misunderstanding from C users is pass-by-reference/value. Julia behaves the same as in Python. For example,</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = <span class=hljs-number >1</span>
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > b = a
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > b = <span class=hljs-number >2</span>
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > a</span></code></pre>
<p>what do you expect for the value of a? Because a is immutable, it will not change from 1 to 2&#33; However, the following</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = [<span class=hljs-number >1</span>,<span class=hljs-number >2</span>]
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > b = a
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > b[<span class=hljs-number >1</span>] = <span class=hljs-number >2</span>
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > a</span></code></pre>
<p>is different, because array is mutable object. Therefore the value of a should be <code>&#91;2,2&#93;</code>.</p>
<ul>
<li><p>Arrays and vectors are tricky.</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = [<span class=hljs-string >&quot;1&quot;</span>,<span class=hljs-string >&quot;2&quot;</span>]
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > a = [<span class=hljs-string >&quot;1&quot;</span> <span class=hljs-string >&quot;2&quot;</span>]
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > a = [<span class=hljs-string >&quot;1&quot;</span>;<span class=hljs-string >&quot;2&quot;</span>]
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > reshape(a,:,<span class=hljs-number >1</span>)
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > reshape(a,<span class=hljs-number >1</span>,:)</span></code></pre>
<ul>
<li><p>Object and reference needs special attention. Strings are immutable, therefore you cannot do operations like </p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = <span class=hljs-string >&quot;hello&quot;</span>; a[<span class=hljs-number >2</span>] = <span class=hljs-string >&quot;a&quot;</span></span></code></pre>
<p>On the other hand, arrays are mutable, which makes it important to distinguish between aliasing and copying. For example,</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = [<span class=hljs-number >1</span>,<span class=hljs-number >2</span>,<span class=hljs-number >3</span>]; b = a; b[<span class=hljs-number >1</span>] = <span class=hljs-number >42</span>; println(a)</span></code></pre>
<p>will also change the values of <code>a</code>. The slicing operation <code>&#91;:&#93;</code> means copying, and the heavy memory usage compared to in-place manipulations is probably one of the reasons Julia encourages de-vectorized code. However, I am not entirely sure about what will be happening if the dot syntax is used together with slicing. As a side note, MATLAB uses &quot;lazy copy&quot; strategy.</p>
<ul>
<li><p>If I define a macro and execute the script again after the first one, it always says <code>invalid redefinition of constant ...</code>.</p>

</ul>
<ul>
<li><p>syntax: invisible character <code>\u2060</code>.</p>

</ul>
<p>This happens once when I was using unicode. <code>\u2060</code> is called word joiner.</p>
<ul>
<li><p>I once encountered an error when using the ODE solvers. It turned out that the problem is I do not set the initial conditions with the correct types...</p>

</ul>
<ul>
<li><p>For a container-like thing, Julia used to have <code>type</code> keyword, but it is removed after version 0.7. Now only <code>struct</code> is used.</p>

</ul>
<ul>
<li><p>Strings can be treated as a list of characters, so we can index into them–- that is, access the character at a certain position in the word. It is important to notice that indexing via a singular value returns a <code>Char</code>, while indexing via a range returns a <code>String</code> &#40;remember, for Julia these are two completely different things&#41;.</p>

</ul>
<ul>
<li><p>In Julia, string literals are encoded using UTF-8. UTF-8 is a variable-width encoding, meaning that not all characters are represented using the same number of bytes. For example, ASCII characters are encoded using a single byte–- but other characters can use up to four bytes. This means that not every byte index into a UTF-8 string is necessarily a valid index for a corresponding character. If you index into a string at such an invalid byte index, an error will be thrown. Here is what I mean:</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > str = <span class=hljs-string >&quot;Søren Kierkegaard was a Danish Philosopher&quot;</span> 
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > str[<span class=hljs-number >1</span>] 
</span>
&#x27;S&#x27;: ASCII/Unicode U+0053 (category Lu: Letter, uppercase)
<span class=hljs-meta >julia&gt;</span><span class=julia > str[<span class=hljs-number >2</span>] 
</span>
&#x27;ø&#x27;: Unicode U+00f8 (category Ll: Letter, lowercase) 
<span class=hljs-meta >julia&gt;</span><span class=julia > str[<span class=hljs-number >3</span>] 
</span>
StringIndexError(&quot;Søren Kierkegaard was a Danish Philosopher&quot;, 3)
<span class=hljs-meta >julia&gt;</span><span class=julia > str[<span class=hljs-number >4</span>] 
</span>
&#x27;r&#x27;: ASCII/Unicode U+0072 (category Ll: Letter, lowercase)</code></pre>
<ul>
<li><p>MySQL is too prone to error on my Mac. The API is not good enough for a stable development for a rookie like me.</p>

</ul>
<ul>
<li><p>It is worth remembering that <code>transpose</code> creates a thin wrapper around the original array. This means that if we modify the transposed matrix, the original will also be modified&#33;</p>

</ul>
<ul>
<li><p>Declare a global variable <code>const</code> does not mean you cannot change the values. It just means that you can no longer reassign the variable but if it refers to a mutable value, you can modify the value. In other words, the type and size of the variable is set, but not the values it stores. &#40;Actually what I found is that you can assign it to other variables, but Julia will give you a warning. According to the manuals, this is mainly for performance reasons.&#41;</p>

</ul>
<ul>
<li><p>Recursion with dynamic programming: a key idea is called <strong>memoization</strong>. Compare the following two versions of calculating Fibonacci sequence:</p>

</ul>
<pre><code class="julia-repl hljs"># Classical version                                                             
function fib(n)
   if n == 0
      return 0
   elseif n == 1
      return 1
   else
      return fib(n-1) + fib(n-2)
   end
end

# Memoized version                                                              
const known = Dict(0=&gt;0, 1=&gt;1)

function fibonacci(n)
   if n ∈ keys(known)
      return known[n]
   else
      res = fibonacci(n-1) + fibonacci(n-2)
      known[n] = res
      return res
   end
end</code></pre>
<p>The second version is much faster than the first classical version because of the reuse of already known values.</p>
<ul>
<li><p>Julia 1.0 does not support <code>copy&#33;</code>, but it does in Julia 1.1&#43;. As a workaround, you can use <code>a .&#61; b</code> instead of <code>copy&#33;&#40;a,b&#41;</code>. Note that <code>a &#61; b</code> won&#39;t work here if <code>a</code> is immutable.</p>

</ul>
<ul>
<li><p>Once I wanted to create an array of arrays and append items to each later on. This was what I did:</p>

</ul>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = <span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Vector</span>{<span class=hljs-built_in >Int</span>}}(<span class=hljs-literal >undef</span>,<span class=hljs-number >2</span>)
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > push!(a[<span class=hljs-number >1</span>],<span class=hljs-number >1</span>)
</span>
ERROR: UndefRefError: access to undefined reference</code></pre>
<p>An even more strange thing happened for <code>fill</code>:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a = fill(<span class=hljs-built_in >Int</span>[],<span class=hljs-number >2</span>)
</span>
<span class=hljs-meta >julia&gt;</span><span class=julia > push!(a[<span class=hljs-number >1</span>],<span class=hljs-number >1</span>)</span></code></pre>
<p>Guess what I got? All the arrays are identical, which means that they are actually referred to the same memory allocation&#33; This can only be avoided if I set each to a different value:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > a[<span class=hljs-number >1</span>] = [<span class=hljs-number >1</span>]</span></code></pre>
<p>Then <code>a&#91;1&#93;</code> is detached, but <code>a&#91;2&#93;</code> and <code>a&#91;3&#93;</code> are still pointing to the same memory allocation&#33; What I ended up doing is:</p>
<pre><code class="julia-repl hljs"><span class=hljs-meta >julia&gt;</span><span class=julia > <span class=hljs-keyword >for</span> i=<span class=hljs-number >1</span>:length(a) a[i] = [] <span class=hljs-keyword >end</span></span></code></pre>
<p>This behavior is so weird&#33; Be careful about all the related functions like <code>zeros,ones</code>.</p>
<ul>
<li><p>for loops not inside functions &#40;e.g. in REPL&#41; does not inherit the variables from global scope.</p>

</ul>
<ul>
<li><p>There are many issues in 3D visualzation in Plots.jl. For example, zlabel is not working at all, as of Julia 1.2.</p>

</ul>
<ul>
<li><p>pyplot backend issue. In Juno on Windows, by default matplotlib uses a ploting backend with no gui, making it impossible to show figures directly. The solution is to add <code>gcf&#40;&#41;</code> to the end of your code.</p>

</ul>
<ul>
<li><p>The <code>Plot.jl</code> library of Julia is not mature yet as of Julia 1.0. For example, the equal x,y,z range has no effect; the z label has some issue; the name for label and legend is confusing; the resolution of the figure changes depending on the way you execute the code; the size of the figure adjustment does not work. I had a much better experience with <code>PyPlot</code> package directly. It is identical to the Python version &#40;except the enforced double quote&#41; and very similar to a MATLAB user.</p>

</ul>
<ul>
<li><p>I falled into the issue of installing <code>PyPlot.jl</code> again on Raspberry Pi, ARM 64 bit version Ubuntu. Tried all the possible solutions, but nothing helped.</p>

</ul>
<ul>
<li><p>Be careful with filename <code>test.jl</code>, because it may conflict with the built-in test functions&#33;</p>

</ul>
<ul>
<li><p>Do you know how to pass C function as arguments in Julia?</p>

</ul>
<ul>
<li><p>When I was developing the <a href="https://github.com/henry2004y/IDL.jl">IDL.jl</a> package, I encountered an issue with REPL during testing:</p>

</ul>
<pre><code class="julia-repl hljs">ERROR: LoadError: InitError: UndefVarError: active_repl not defined</code></pre>
<p>This <code>active_repl</code> is actually a global variable for the current active REPL you are using. If you are in the testing environment, there&#39;s no active repl, so the above error raises up. The simple solution is to return the function before touching this line, or just create an instance with empty fields.</p>
<ul>
<li><p>In function arguments definition, <code>func&#40;a::Bool&#61;true&#41;</code> is different from <code>func&#40;a&#61;true&#41;</code> in that if you have <code>func&#40;1&#41;</code> the former version will return error for you. This might be better for error checking.</p>

</ul>
<ul>
<li><p>During the surface flux integral, I used the <code>quantile&#33;</code> function from the <code>Statistics</code> package to check the outlier data points. By the exclamation mark <code>&#33;</code> itself you can guess that it changes the input argument, which is not what I want. The correct one to use is <code>quantile</code>.</p>

</ul>
<p>As similar mistakes happen so many time, I need to warn myself again: follow the principle coding rules is the best way to avoid mistakes. Things will accumulate, either good or bad.</p>
<ul>
<li><p>As of Julia 1.5, there is no way to switch off asserts in the code. Hopefully this feature will be added in the future.</p>

</ul>
<ul>
<li><p>The package management system still needs to be improved. Compatibility issues happen from time to time if I have already installed many packages.</p>

</ul>
<div class=page-foot >
  <div class=copyright >
    &copy; Hongyang Zhou. Last modified: January 23, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
      </div> 
  </div> 
  <script src="/JuliaNotes/libs/pure/ui.min.js"></script>