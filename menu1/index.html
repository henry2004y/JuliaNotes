<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/JuliaNotes/libs/highlight/github.min.css"> <link rel=stylesheet  href="/JuliaNotes/css/franklin.css"> <link rel=stylesheet  href="/JuliaNotes/css/pure.css"> <link rel=stylesheet  href="/JuliaNotes/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/JuliaNotes/assets/favicon.png"> <title>Common Questions</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/JuliaNotes/" class=pure-menu-link >Home</a> <li class="pure-menu-item pure-menu-selected"><a href="/JuliaNotes/menu1/" class=pure-menu-link >Questions</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu2/" class=pure-menu-link >Types</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu3/" class=pure-menu-link >Meta</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu4/" class=pure-menu-link >Parallel</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu5/" class=pure-menu-link >Interoperability</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu6/" class=pure-menu-link >Issues and Tricks</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu7/" class=pure-menu-link >Perception</a> </ul> </div> </div> <div id=main > <div class=header > <h1>Common Questions</h1> <h2>Notes taken during the learning process</h2> </div> <div class=franklin-content ><h1 id=language_features ><a href="#language_features" class=header-anchor >Language Features</a></h1> <div class=franklin-toc ><ol><li><a href="#multiple-dispatch_and_function_overloading">Multiple-dispatch and function overloading</a><li><a href="#objects">Objects</a><ol><li><a href="#objects_passing_behavior">Objects passing behavior</a></ol><li><a href="#type_conversion_and_variable_definition">Type conversion and variable definition</a><li><a href="#unicode_support">Unicode support</a><li><a href="#dot_operators">Dot operators</a><li><a href="#splat_operator">Splat operator</a><li><a href="#functions">Functions</a><li><a href="#scopes">Scopes</a><li><a href="#control_flow">Control Flow</a><ol><li><a href="#ternary_operator">Ternary operator</a><li><a href="#short-circuit_evaluation">Short-circuit evaluation</a><li><a href="#beware_of_operator_precedence">Beware of operator precedence</a></ol><li><a href="#gpu">GPU</a><li><a href="#live_evaluation_of_code_blocks">Live evaluation of code blocks</a></ol></div> <h2 id=multiple-dispatch_and_function_overloading ><a href="#multiple-dispatch_and_function_overloading" class=header-anchor >Multiple-dispatch and function overloading</a></h2> <p>One of the most common questions people ask when first learning Julia is: what is the difference between multiple-dispatch and function overloading? Here is a nice example for demonstrating the difference.</p> <p><pre><code class=language-julia >abstract type Pet end
struct Dog &lt;: Pet
    name::String
end
struct Cat &lt;: Pet
    name::String
end

function encounter&#40;a::Pet, b::Pet&#41;
    verb &#61; meets&#40;a,b&#41;
    println&#40;&quot;&#36;&#40;a.name&#41; meets &#36;&#40;b.name&#41; and &#36;verb&quot;&#41;
end

meets&#40;a::Dog, b::Dog&#41; &#61; &quot;sniffs&quot;
meets&#40;a::Dog, b::Cat&#41; &#61; &quot;chases&quot;
meets&#40;a::Cat, b::Dog&#41; &#61; &quot;hisses&quot;
meets&#40;a::Cat, b::Cat&#41; &#61; &quot;slinks&quot;

fido &#61; Dog&#40;&quot;Fido&quot;&#41;
rex  &#61; Dog&#40;&quot;Rex&quot;&#41;
whiskers &#61; Cat&#40;&quot;Whiskers&quot;&#41;
spots &#61; Cat&#40;&quot;Spots&quot;&#41;

encounter&#40;fido, rex&#41;
encounter&#40;fido, whiskers&#41;
encounter&#40;whiskers, rex&#41;
encounter&#40;whiskers, spots&#41;</code></pre> </p> <p>which gives: <pre><code class="plaintext code-output">Fido meets Rex and sniffs
Fido meets Whiskers and chases
Whiskers meets Rex and hisses
Whiskers meets Spots and slinks</code></pre> </p> <p>The translation to C&#43;&#43;: <pre><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Pet&#123;
   public:
      string name;
&#125;;

string meets&#40;Pet a, Pet b&#41;&#123; return &quot;FALLBACK&quot;;&#125;

void encounter&#40;Pet a, Pet b&#41;&#123;
   string verb &#61; meets&#40;a, b&#41;;
   cout &lt;&lt; a.name &lt;&lt; &quot; meets&quot;
        &lt;&lt; b.name &lt;&lt; &quot; and &quot; &lt;&lt; verb &lt;&lt; endl;
&#125;

class Dog : public Pet &#123;&#125;;
class Cat : public Pet &#123;&#125;;

string meets&#40;Dog a, Dog b&#41; &#123;return &quot;sniffs&quot;;&#125;
string meets&#40;Dog a, Cat b&#41; &#123;return &quot;chases&quot;;&#125;
string meets&#40;Cat a, Dog b&#41; &#123;return &quot;hisses&quot;;&#125;
string meets&#40;Cat a, Cat b&#41; &#123;return &quot;slinks&quot;;&#125;

int main&#40;&#41;&#123;
   Dog fido, rex;
   Cat whiskers, spots;

   fido.name &#61; &quot;Fido&quot;;
   rex.name &#61; &quot;Rex&quot;;
   whiskers.name &#61; &quot;Whiskers&quot;;
   spots.name &#61; &quot;Spots&quot;;

   encounter&#40;fido, rex&#41;;
   encounter&#40;fido, whiskers&#41;;
   encounter&#40;whiskers, rex&#41;;
   encounter&#40;whiskers, spots&#41;;

   return 0;
&#125;</code></pre> </p> <p>which gives: <pre><code class="language-c++">Fido meets Rex and FALLBACK
Fido meets Whiskers and FALLBACK
Whiskers meets Rex and FALLBACK
Whiskers meets Spots and FALLBACK
</code></pre></p> <h2 id=objects ><a href="#objects" class=header-anchor >Objects</a></h2> <p>Like Python, everything is an object. Objects can be mutable or immutable, depending on if they can be modified after creation or not.</p> <h3 id=objects_passing_behavior ><a href="#objects_passing_behavior" class=header-anchor >Objects passing behavior</a></h3> <p>Indeed it is confusing to distinguish between pass-by-value, pass-by-reference, and pass-by-sharing. The behavior of Julia is similar to Python, but different from C. Briefly speaking, mutable and immutable objects behave differently, and it is often the immutable objects like <code>tuple</code> or <code>struct</code> that cause issues. Check <a href="https://www.python-course.eu/passing_arguments.php#:~:text&#61;Correctly&#37;20speaking&#37;2C&#37;20Python&#37;20uses&#37;20a,like&#37;20call&#37;2Dby&#37;2Dvalue.">this Python course</a> for details.</p> <p>Previously I had some misunderstandings about Julia functions, especially about the argument passing behaviour. Strictly speaking, Julia is <strong>call-by-value where the value is a reference</strong>, or <strong>call-by-sharing</strong>, as used by most languages. This means that even without a &quot;&#33;&quot; mark, the arrays are passed-by-reference, and scalars are passed-by-value. The exclamation mark <code>&#33;</code> is just a convention for programmers to notify that a function may change the arguments, but it does not necessarily do anything to force it.</p> <p>A common mistake/bug is that you assign part of an array to another variable, and modify the other one.</p> <p>The confusion stems from this: assignment and mutation are not the same thing. Quoted from Steven on StackOverFlow:</p> <ul> <li><p>Assignment. Assignment looks like <code>x &#61; ...</code> –- what&#39;s left of the <code>&#61;</code> is an identifier, i.e. a variable name. Assignment changes which object the variable <code>x</code> refers to &#40;this is called a variable binding&#41;. It does not mutate any objects at all.</p> <li><p>Mutation. There are two typical ways to mutate something in Julia: <code>x.f &#61; ...</code> –- what&#39;s left of the <code>&#61;</code> is a field access expression; <code>x&#91;i&#93; &#61; ...</code> –- what&#39;s left of the <code>&#61;</code> is an indexing expression. Currently, field mutation is fundamental –- that syntax can only mean that you are mutating a structure by changing its field. This may change. Array mutation syntax is not fundamental –- <code>x&#91;i&#93; &#61; y</code> means <code>setindex&#33;&#40;x, y, i&#41;</code> and you can either add methods to <code>setindex&#33;</code> or locally change which generic function <code>setindex&#33;</code>. Actual array assignment is a builtin –- a function implemented in C &#40;and for which we know how to generate corresponding LLVM code&#41;.</p> </ul> <p>Mutation changes the values of objects; it doesn&#39;t change any variable bindings. After doing either of the above, the variable <code>x</code> still refers to the same object it did before; that object may have different contents, however. In particular, if that object is accessible from some other scope –– say the function that called one doing the mutation –- then the changed value will be visible there. But no bindings have changed –- all bindings in all scopes still refer to the same objects.</p> <p>You&#39;ll note that in this explanation I never once talked about mutability or immutability. That&#39;s because it has nothing to do with any of this –- mutable and immutable objects have exactly the same semantics when it comes to assignment, argument passing, etc. The only difference is that if you try to do <code>x.f &#61; ...</code> when x is immutable, you will get an error.</p> <h2 id=type_conversion_and_variable_definition ><a href="#type_conversion_and_variable_definition" class=header-anchor >Type conversion and variable definition</a></h2> <p>Julia inference system is smart enough to output</p> <pre><code class=language-julia >5 / 2</code></pre>
<p>as</p>
<pre><code class=language-julia >2.5</code></pre>
<p>As a common potential issue for dynamic languages, due to the lack of requirement of variable definition, implicit type conversion as well as surprising temporary memory allocation of intermediate variables may happen and is hard to debug/optimize. This is really a double-edge sword, so be careful to make good use of it&#33;</p>
<h2 id=unicode_support ><a href="#unicode_support" class=header-anchor >Unicode support</a></h2>
<p>As a math-friendly language, Julia has nice integrated support for Unicode-8. This means that not only you can use greek letters with sub/super-script for variable names, but also frequently you can see more than one syntax of expressing the same result, such as</p>
<pre><code class=language-julia >&#40;∈, in&#41;
&#40;&#40;f ∘ g&#41;&#40;args...&#41;, f&#40;g&#40;args...&#41;&#41;&#41;</code></pre>
<p>and many others.</p>
<h2 id=dot_operators ><a href="#dot_operators" class=header-anchor >Dot operators</a></h2>
<p><code>.</code> in Julia has two usages:</p>
<ol>
<li><p>access fields or properties of objects and access variables defined inside modules.</p>

<li><p>Perform broadcasted operations.</p>

</ol>
<p>Let us focus on the broadcast feature, or vectorization, as many people call it. Julia defines corresponding dot operations for every binary operator. These are designed to work element-wise with collections of values. That is, the operator that is dotted is applied for each element of the collection. At first this may be uncomfortable for MATLAB programmers, because in MATLAB often you don&#39;t need to use dot as it is implicitly inferred. However from a language perspective, it is more strict and general to define a broadcast operation, or for short notation, <code>.</code>. Given that applying dot operator to all the places may be hard to read, Julia provides a macro <code>@.</code> that can be used at the beginning of an expression to indicate that each variable that is not protected by a preceding <code>&#36;</code> sign is treated as broadcasted collection.</p>
<p>Vectorized code is an important part of the language due to its readability and conciseness, but also because it provides important performance optimizations. In general, Julia community recommend de-vectorized codes to speed up the code, as in C and Fortran. The vectorized codes are not as fast as their de-vectorized version. Obviously the developer are trying to catch up. See <a href="https://julialang.org/blog/2017/01/moredots">More Dots: Syntactic Loop Fusion in Julia</a>. What I notice in practice is that the broadcast version usually allocates more memory, but the performance is only slightly behind.</p>
<h2 id=splat_operator ><a href="#splat_operator" class=header-anchor >Splat operator</a></h2>
<p>Sometime you will see this <code>...</code> operator: it is called splat. It is often handy to &quot;splat&quot; the values contained in an iterable collection into a function call as individual arguments.</p>
<p>A range can be expanded into its corresponding values by using the splat operator <code>...</code>. For example, we can splat it into a tuple:</p>
<pre><code class=language-julia >@show &#40;20:-5:-20...,&#41;</code></pre>
<pre><code class="plaintext code-output">(20:-5:-20...,) = (20, 15, 10, 5, 0, -5, -10, -15, -20)
</code></pre>
<p>We can also splat it into a list:</p>
<pre><code class=language-julia >@show &#91;1:10...&#93;</code></pre>
<pre><code class="plaintext code-output">[1:10...] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
</code></pre>
<h2 id=functions ><a href="#functions" class=header-anchor >Functions</a></h2>
<p>Note the ending exclamation mark &#33; for some functions. These are perfectly legal function name in Julia. It is a <strong>convention</strong> to warn that the function is mutating–-that is, it will modify the data passed as argument to it, instead of returning a new value.</p>
<h2 id=scopes ><a href="#scopes" class=header-anchor >Scopes</a></h2>
<p>It&#39;s very important to keep in mind that <code>if</code> blocks do not introduce local scope. That is, variables defined within them will be accessible after the block is exited &#40;of course, provided that the respective branch has been evaluated&#41;:</p>
<pre><code class=language-julia >status &#61; if x &lt; 0 
            &quot;x is a negative number&quot; 
         elseif x &gt; 0 
            y &#61; 20 
            &quot;x is a positive number greater than 0&quot; 
         else  
            &quot;x is 0&quot; 
         end 
y</code></pre>
<p>We can see here that the <code>y</code> variable, initialized within the <code>elseif</code> block, is still accessible outside the conditional expression.</p>
<p>This can be avoided if we declare the variable to be local:</p>
<pre><code class=language-julia >status &#61; if x &lt; 0 
            &quot;x is a negative number&quot; 
         elseif x &gt; 0 
            local z &#61; 20 
            &quot;x is a positive number greater than 0&quot; 
         else  
            &quot;x is 0&quot; 
         end 
z # UndefVarError: z not defined</code></pre>
<h2 id=control_flow ><a href="#control_flow" class=header-anchor >Control Flow</a></h2>
<h3 id=ternary_operator ><a href="#ternary_operator" class=header-anchor >Ternary operator</a></h3>
<p>Similar to C, an <code>if,then and else</code> type of condition can be expressed using the ternary operator <code>? :</code>.</p>
<p>For instance, </p>
<pre><code class=language-julia >x &#61; 10
x &lt; 0 ? &quot;negative&quot; : &quot;positive&quot;</code></pre>
<h3 id=short-circuit_evaluation ><a href="#short-circuit_evaluation" class=header-anchor >Short-circuit evaluation</a></h3>
<p>Julia provides an even more concise type of evaluation –- short-circuit evaluation &#40;exactly the same thing as in MATLAB&#41;. In a series of Boolean expressions connected by <code>&amp;&amp;</code> and <code>||</code> operators, only the minimum number of expressions are evaluated—as many as are necessary in order to determine the final Boolean value of the entire chain. We can exploit this to return certain values, depending on what gets to be evaluated. For instance:</p>
<pre><code class=language-julia >x &#61; 10
x &gt; 5 &amp;&amp; &quot;bigger than 5&quot; # &quot;bigger than 5&quot;</code></pre>
<p>In an expression <code>A &amp;&amp; B</code>, the second expression B is only evaluated if and only if A evaluates to true. In this case, the whole expression has the return value of the sub-expression B, which in the previous example is bigger than 5.</p>
<p>If, on the contrary, A evaluates to false, B does not get evaluated at all. Thus, beware –- the whole expression will return a false Boolean &#40;not a string&#33;&#41;:</p>
<pre><code class=language-julia >x &gt; 15 &amp;&amp; &quot;bigger than 15&quot;</code></pre>
<p>The same logic applies to the logical or operator, <code>||</code>:</p>
<pre><code class=language-julia >x &lt; 5 || &quot;greater than 5&quot;</code></pre>
<p>In an expression <code>A || B</code>, the second expression B is only evaluated if A evaluates to false. The same logic applies when the first sub-expression is evaluated to true; true will be the return value of the whole expression:</p>
<pre><code class=language-julia >x &gt; 5 || &quot;less than 5&quot;</code></pre>
<h3 id=beware_of_operator_precedence ><a href="#beware_of_operator_precedence" class=header-anchor >Beware of operator precedence</a></h3>
<p>Sometimes short-circuit expressions can confuse the compiler, resulting in errors or unexpected results. For example, short-circuit expressions are often used with assignment operations, as follows:</p>
<pre><code class=language-julia >x &gt; 15 || message &#61; &quot;That&#39;s a lot&quot;</code></pre>
<p>This will fail with the syntax: <code>invalid assignment location &quot;&#40;x &gt; 15&#41; || message</code> error because the <code>&#61;</code> assignment operator has higher precedence than logical <code>or</code> and <code>||</code>. It can easily be fixed by using brackets to explicitly control the evaluation order:</p>
<pre><code class=language-julia >x &gt; 15 || &#40;message &#61; &quot;That&#39;s a lot&quot;&#41;</code></pre>
<p>It&#39;s something to keep in mind as it&#39;s a common source of errors for beginners.</p>
<h2 id=gpu ><a href="#gpu" class=header-anchor >GPU</a></h2>
<p>The capability of generating assembly code from Julia makes it possible to take advantage of the CUDA C API and pass instructions to the backend GPU compiler. Writing CUDA code in Julia is by far the easiest way to do it besides C/C&#43;&#43; and Fortran: I have created a <a href="https://github.com/henry2004y/GPU-Collection/tree/master/julia">repository</a> for the small examples.</p>
<p>Check out this <a href="https://notamonadtutorial.com/julia-gpu-98a461d33e21">interview of Time Besard</a> for the logics and progress of GPU programming in Julia.</p>
<p>CUDA.jl is bundled with an advising tool for the optimal blocks and threads for your kernel on this specific hardware. Besides, the profiler and tracer from Nvidia is fully compatible with CUDA.jl.</p>
<h2 id=live_evaluation_of_code_blocks ><a href="#live_evaluation_of_code_blocks" class=header-anchor >Live evaluation of code blocks</a></h2>
<p>If you would like to show code as well as what the code outputs, you only need to specify where the script corresponding to the code block will be saved.</p>
<p>Indeed, what happens is that the code block gets saved as a script which then gets executed. This also allows for that block to not be re-executed every time you change something <em>else</em> on the page.</p>
<p>Here&#39;s a simple example &#40;change values in <code>a</code> to see the results being live updated&#41;:</p>
<pre><code class=language-julia >using LinearAlgebra
a &#61; &#91;1, 2, 3, 3, 4, 5, 2, 2&#93;
@show dot&#40;a, a&#41;
println&#40;dot&#40;a, a&#41;&#41;</code></pre>
<p>You can now show what this would look like:</p>
<pre><code class="plaintext code-output">dot(a, a) = 72
72
</code></pre>
<div class=page-foot >
  <div class=copyright >
    &copy; Hongyang Zhou. Last modified: October 03, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
      </div> 
  </div> 
  <script src="/JuliaNotes/libs/pure/ui.min.js"></script>
  
  
      <script src="/JuliaNotes/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>