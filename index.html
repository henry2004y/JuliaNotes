<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/JuliaNotes/css/franklin.css"> <link rel=stylesheet  href="/JuliaNotes/css/pure.css"> <link rel=stylesheet  href="/JuliaNotes/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/JuliaNotes/assets/favicon.png"> <title>Coding in Julia</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item pure-menu-selected"><a href="/JuliaNotes/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu1/" class=pure-menu-link >Questions</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu2/" class=pure-menu-link >Types</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu3/" class=pure-menu-link >Meta</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu4/" class=pure-menu-link >Parallel</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu5/" class=pure-menu-link >Interoperability</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu6/" class=pure-menu-link >Issues and Tricks</a> <li class="pure-menu-item "><a href="/JuliaNotes/menu7/" class=pure-menu-link >Perception</a> </ul> </div> </div> <div id=main > <div class=header > <h1>Coding in Julia</h1> <h2>Notes taken during the learning process</h2> </div> <div class=franklin-content ><h1 id=overview ><a href="#overview" class=header-anchor >Overview</a></h1> <p><div class=franklin-toc ><ol><li><a href="#how_julia_works">How Julia works</a><li><a href="#big_pictures_to_keep_in_mind">Big pictures to keep in mind</a><li><a href="#why_julia">Why Julia</a><li><a href="#getting_help">Getting help</a><ol><li><a href="#references">References</a></ol></ol></div> </p> <h2 id=how_julia_works ><a href="#how_julia_works" class=header-anchor >How Julia works</a></h2> <p>The Julia compiler workflow is presented in <a href="https://www.youtube.com/watch?v&#61;7KGZ_9D_DbI&amp;list&#61;WL&amp;index&#61;6">Jameson Nash&#39;s talk</a>. The key essense is shown in the structure below:</p> <ul> <li><p>method definition</p> <ul> <li><p>macros, metaprogramming</p> </ul> <li><p>code_lowered</p> <ul> <li><p>generated functions</p> <li><p>simplified code structure</p> </ul> <li><p>code_typed</p> <ul> <li><p>precompiled modules &#40;.ji&#41;</p> <li><p>global inference</p> <li><p>local optimization</p> <li><p>code_warntype: dynamic behavior annotations</p> </ul> <li><p>code_llvm</p> <ul> <li><p>external codegen</p> <li><p>llvm-2.0 Julep Intermediate Representation &#40;IR&#41; for low-level optimization</p> </ul> <li><p>code_native</p> <ul> <li><p>static system image &#40;.so/.dll/.dylib&#41;</p> <li><p>machine code representation</p> </ul> </ul> <p>If one dive deeper into the processor, he/she will find that it handles the machine code in a way similar to Julia&#39;s workflow, with multiple levels of caching and optimization.</p> <p>So what&#39;s unique about Julia in the sense of a new programming language? It all lies in the <strong>code_typed</strong> process which is closely related to <strong>Interprocedural Optimization &#40;IPO&#41;</strong>. Julia has implemented a dataflow inference algorithm that runs Ahead of Time &#40;AOT&#41;, which is different from the common Just-In-Time &#40;JIT&#41; compilation that people talk about. This is also the reason why Julia takes a significant amount of time the first time it executes the code: for later runs, the compiler caches previous machine codes and will only rerun the compilation process for the modified codes.</p> <h2 id=big_pictures_to_keep_in_mind ><a href="#big_pictures_to_keep_in_mind" class=header-anchor >Big pictures to keep in mind</a></h2> <p>In a compiled language like Julia, loops are most-of-the-time better than vectorization, even though vectorized version may be shorter and cleaner. This is mainly because a vectorized version creates many temporary variables behind the scene, and memory allocation is slow compared to operations. So when writing Julia code, it is like a combination of interpreting language like MATLAB and compiled language like Fortran: you need to think both ways to get the most out of Julia.</p> <p>When people like me jumps into the Julia world, we would often love to convert our existing codes from other languages into Julia and check if it shows the promised performance. This is the time we truly learn Julia the Julian way.</p> <p>What I really love about Julia is its desire to point out the deficiencies of other languages&#39; implementations and improve from them. Being a new language in the competitive world, Julia grows in the open source community with support from enthusiasts, and is now gaining attention from the mainstream science and business fields.</p> <p>Learning new things is fun. Starting to code in Julia, there are several things you should keep in mind:</p> <ol> <li><p>Julia is not an OOP language, but everything in Julia is an object. In Julia, we use what is being called <strong>multiple dispatch</strong> to do things like <em>overloading</em>. To write good Julia code, you need to adopt the method-focused workflow and rethink about the knowledge you have about OOP and functional programming.</p> <li><p>My first implementation of KEMPO1, a 1D PIC code originally writeen in MATLAB, ran 50&#37; slower than the MATLAB version even without graphics&#33; This was really surprising to me, but it also showed that I was not familiar with Julia at all. The lesson is that type stability is extremely important in Julia. Just by making the code type-stable results in a 50x speedup&#33; For sure more tricks can be applied: for instance, somebody who came from the Haskel world posted a case on Discourse with a program of simple geometry accelerated by 1000x.</p> <li><p>The conversion from C/Fortran/Python into Julia is easy. However, Julia has 1-based indexing, the same as MATLAB/Fortran as opposed to the 0-based indexing in C/C&#43;&#43;/Python. This is the error-prone part during the conversion. If you consider it really necessary, Julia has support for arrays with arbitrary indices, allowing, for example, to start numbering at 0. This is widely used in the image processing packages. If you are curious, check the <a href="https://docs.julialang.org/en/v1/devdocs/offset-arrays/">official documentation</a>.</p> <li><p>At the current stage, a realistic expectation for Julia program compared with C/C&#43;&#43;/Fortran is that the timings should be within a factor of 3. In certain cases, Julia can even outperform them &#40;e.g. 1D Vlasov demo&#41;.</p> </ol> <h2 id=why_julia ><a href="#why_julia" class=header-anchor >Why Julia</a></h2> <p>Fast implementation, easy maintenance and decent performance.</p> <p>As quoted from Christopher Rackauckas, all the micro-examples performed as benchmarks for Julia, Numba, Cython and others will show only tiny differences. Actually nowadays with the advance of LLVM backend any any sufficient competent IR generating mechanism will hit the performance limit on small examples &#40;as shown with the compilation stages above&#41;.</p> <p>What really matters is whether it can scale into large projects. Chris showed an example of 10x faster performance achieve by the <em>Julia called from Python</em> solution than the SciPy&#43;Numba code, which is essentially just a full Julia vs Fortran&#43;Numba solution. The main issue is that Fortran&#43;Numba still has Python context switches in there because the two pieces were independently compiled and it&#39;s this which becomes the remaining bottleneck that cannot be erased.</p> <p>On the other hand, the Cython approach, where you can design the entire package yourself as one monolithic code base, will become maintenance nightmares which decrease programming productivity since you&#39;ll have to reinvent the wheel. And the even larger issue in scientific computing is that it is the intersection of high performance computational utilities with complex mathematical algorithms that gives you strong performance. Rewriting every single difficult algorithm from scratch in order to utilize the most modern methods with the most efficient structures is not a style of programming that scales well. If there&#39;s one thing that Python really does well, I would say it&#39;s the package ecosystem. Julia learns from Python and now has a really good package system, and we have the ability to have separate packages work fully together.</p> <p>The key difference between Cython and Julia:</p> <ul> <li><p>In Cython you have separately compiled functions and packages, much like static compilation to shared libraries in C&#43;&#43;, and then you put function calls between them. In a few cases where you compile parts together it can inline, but generally you have separate packages/modules/etc. compile separately. This cuts down on compile time and makes it easier to generate a static binary but adds runtime costs.</p> <li><p>In Julia you have fully dependent compilation. Packages which call other packages can take control of the full code before compilation and then choices have to be made at how to separate it in a meaningful way.</p> </ul> <p>This will lead to the next part: once you have the entire code of a function, you can use the dependent compilation to build alternative output functions at compile time. These are language level compilation control features, which can really help to interact with the efficient data structures and difficult algorithms. A good example is the combination usage of dual numbers in <em>automatic differentiation</em> and <em>ODE solvers</em>. Another example is the <em>porting to GPU</em> process, which basically requires nothing if you are using broadcast.</p> <p>Dependent compilation fully eliminates the overhead that exists when different libraries are separately compiled. Broadcast overrides allow you to dictate how internal structures of scientific computing codes should be implemented and optimized on your specific model.</p> <p>There is a tradeoff for all these amazing things to happen: compile-time. For this system to be used interactively, you have to take a step back and find out where you want to stop specializing and where to put up artificial walls. A combination of statically compiled and dynamically compiled code is also an engineering challenge.</p> <h2 id=getting_help ><a href="#getting_help" class=header-anchor >Getting help</a></h2> <p>If you know the names of unsure functions and operators, type <code>?</code> in the Julia REPL followed by the function/operator name. It will show the comments from the source code.</p> <p>In many circumstances you can find the solutions to your question online. In case you fail, people in the community are generally helpful. Most of them work across multiple languages and are very knowledgeable about programming techniques. Either ask questions on the <a href="https://discourse.julialang.org/">main Discourse</a> or the <a href="https://discourse.juliacn.com/">Chinese Discourse</a>. For specific question about packages, go to their GitHub repositories and submit an issue.</p> <p>The language itself gets more stable after 1.0 release, but it&#39;s still changing relatively rapidly. Take a look at <a href="https://www.oxinabox.net/2021/02/13/Julia-1.6-what-has-changed-since-1.0.html">What has changed since 1.0</a> for the gradually evolving new features.</p> <h3 id=references ><a href="#references" class=header-anchor >References</a></h3> <p><a href="https://github.com/PacktPublishing/Julia-Programming-Projects">Julia Programming Projects, Adrian Salceanu</a></p> <p><a href="https://www.juliabloggers.com/new-trends-in-programming-languages/">New Trends in Programming Languages</a></p> <p><a href="https://benlauwens.github.io/ThinkJulia.jl/latest/book.html#_copyright">Think Julia</a></p> <div class=page-foot > <div class=copyright > &copy; Hongyang Zhou. Last modified: October 06, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> <script src="/JuliaNotes/libs/pure/ui.min.js"></script>